## 公众号：“弟哥带你进大厂”，让你知识成体系的公众号，一定要关注，我们一起进大厂

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件:

-   文件事件( file event ) : Redis服务器通过套接字与客户端(或者其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
-   时间事件( time event ) : Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。

本章将对文件事件和时间事件进行介绍，说明这两种事件在Redis服务器中的应用，它们的实现方法，以及处理这些事件的API等等。

本章最后将对服务器的事件调度方式进行介绍，说明Redis服务器是如何安排并执行文件事件和时间事件的。

# 文件事件

Redis基于Reactor模式开发了自己的网络事件处理器:这个处理器被称为文件事件处理器（ file event handler ) :

-   文件事件处理器使用IO多路复用( multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
-   当被监听的套接字准备好执行连接应答( accept)、读取（read)、写入( write)、关闭( close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。

虽然文件事件处理器以单线程方式运行，但通过使用IO多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了Redis 内部单线程设计的简单性。

## 文件事件处理器的构成

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc017b81d5b4cd19b55d95aca9e87c7~tplv-k3u1fbpfcp-zoom-1.image)

图12-1展示了文件事件处理器的四个组成部分，它们分别是套接字、I/O多路复用程序、文件事件分派器(dispatcher)，以及事件处理器。

文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答( accept)、写入、读取、关闭等操作时,就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。

IO多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序( sequentially)、同步( synchronously )、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕)，IO多路复用程序才会继续向文件事件分派器传送下一个套接字，如图12-2所示。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0147241cff34a8d8e11aeb7dd83840c~tplv-k3u1fbpfcp-zoom-1.image)

文件事件分派器接收IO多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。

服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。

## l/O多路复用程序的实现

Redis的IO多路复用程序的所有功能都是通过包装常见的`select`、`epoll`、`vport`和`kqueue`这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如`ae_select.c`、`ae_epoll.c`、`ae_kqueue.c`，诸如此类。因为Redis为每个I/O多路复用函数库都实现了相同的API，所以IO多路复用程序的底层实现是可以互换的，如图12-3所示。

Redis在I/O多路复用程序的实现源码中用#include宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0587aa2c97b444a89ea987f5bbfda5d1~tplv-k3u1fbpfcp-zoom-1.image)

## 事件类型

I/O多路复用程序可以监听多个套接字的`ae.h/AE_READABLE`事件和`ae.h/AE_WRITABLE`事件，这两类事件和套接字操作之间的对应关系如下:

-   当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作)，或者有新的可应答(acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作)，套接字产生`AE_READABLE`事件。
-   当套接字变得可写时（客户端对套接字执行read操作)，套接字产生`AE_WRITABLE`事件。

I/O多路复用程序允许服务器同时监听套接字的`AE_READABLE`事件和`AE_WRITABLE`事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理`AE_READABLE`事件，等到`AE_READABLE`事件处理完之后，才处理AE_WRITABLE事件。

这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。

## api

`ae.c/aeCreateFileEvent`函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I/O多路复用程序的监听范围之内,并对事件和事件处理器进行关联。

`ae.c/aeDeleteFileEvent`函数接受一个套接字描述符和一个监听事件类型作为参数，让IO多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。

`ae.c/aeGetFileEvents `函数接受一个套接字描述符，返回该套接字正在被监听的事件类型:

-   -   如果套接字没有任何事件被监听，那么函数返回AE_NONE。
    -   如果套接字的读事件正在被监听，那么函数返回AE_READABLE。

<!---->

-   -   如果套接字的写事件正在被监听，那么函数返回AE_WRITABLE。
    -   如果套接字的读事件和写事件正在被监听，那么函数返回AE_READABLE I AE_WR工TABLE。

`ae.c/aewait`函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，在给定的时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生，或者等待超时之后，函数返回。

`ae.c/aeApiPoll`函数接受一个`sys/time.h/struct timeval`结构为参数，并在指定的时间内，阻塞并等待所有被aeCreateFileEvent函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生，或者等待超时后，函数返回。

`ae.c/ aeProcessEvents`函数是文件事件分派器，它先调用aeApiPoll函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。

`ae.c/aeGetApiName`函数返回IO多路复用程序底层所使用的IO多路复用函数库的名称:返回"epoll"表示底层为epoll函数库，返回"select"表示底层为select函数库,诸如此类。

## 文件事件的处理器

Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说:

-   -   为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。
    -   为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。

<!---->

-   -   为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。
    -   当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。

在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。

### 连接应答处理器

`networking.c/acceptTcpHandler`函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。

当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的`AE_READABLE`事件关联起来，当有客户端用`sys/socket.h/connect`函数连接服务器监听套接字的时候，套接字就会产生`AE_READABLE`事件，引发连接应答处理器执行，并执行相应的套接字应答操作，如图12-4所示。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757b1054880641ae9089b1695b0152d6~tplv-k3u1fbpfcp-zoom-1.image)

### 命令请求处理器

`networking.c / readQueryFromclient`函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为`unistd.h / read`函数的包装。

当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的`AE_READABLE`事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生AE_READABLE 事件，引发命令请求处理器执行，并执行相应的套接字读入操作，如图12-5所示。

在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的`AE_READABLE`事件关联命令请求处理器。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be354f0c3dda4155a584b14d8a7ae1d9~tplv-k3u1fbpfcp-zoom-1.image)

###

### 命令回复处理器

`networking.c/sendReplyToclient`函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为`unistd.h/write`函数的包装。

当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的`AE_WRITABLE`事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时,就会产生`AE_WRITABLE`事件，引发命令回复处理器执行，并执行相应的套接字写入操作，如图12-6所示。

当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的`AE_WRITABLE`事件之间的关联。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b617dd0e5df4ea3a7ea143574c0d576~tplv-k3u1fbpfcp-zoom-1.image)

**自己总结一下：** 客户端通过连接服务器的监听套接字进行连接，产生`AE_READABLE`事件，然后服务器的监听套接字连接的应答处理器开始执行，创建客户端的套接字，并将客户端的套接字放入队列，并监听该套接字，将客户端套接字的`AE_READABLE`事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生`AE_READABLE`事件，引发命令请求处理器执行，并执行相应的套接字读入操作；当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的`AE_WRITABLE`事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时,就会产生`AE_WRITABLE`事件，引发命令回复处理器执行，并执行相应的套接字写入操作。

注意：客户端连接服务器期间，客户端套接字的`AE_READABLE`事件和命令请求处理器是一直关联的，但当命令回复器将命令回复全都写到套接字之后，客户端套接字的`AE_WRITABLE`事件就会和命令应答服务器断开。

# 时间事件

Redis 的时间事件分为以下两类:

-   定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序X在当前时间的30毫秒之后执行一次。
-   周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序Y每隔30毫秒就执行一次。

一个时间事件主要由以下三个属性组成:

-   id：服务器为时间事件创建的全局唯一ID(标识号)。ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID号要大。
-   when: 毫秒精度的UNIX时间戳，记录了时间事件的到达(arrive)时间。

<!---->

-   timeProc: 时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。

一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:

-   如果事件处理器返回`ae.h/AE_NOMORE`，那么这个事件为定时事件:该事件在达到一次之后就会被删除，之后不再到达。
-   如果事件处理器返回一个非AE_NOMORE 的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。

## 实现

服务器将所有时间事件都放在一个**无序链表(即不按when属性排序)** 中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。

图12-8展示了一个保存时间事件的链表的例子，链表中包含了三个不同的时间事件:因为新的时间事件总是插入到链表的表头，所以三个时间事件分别按ID逆序排序，表头事件的ID为3，中间事件的ID为2，表尾事件的ID为1。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/785bfb298a6448a5a6cc56391cab7059~tplv-k3u1fbpfcp-zoom-1.image)

## API

`ae.c/aeCreateTimeEvent`函数接受一个毫秒数`milliseconds`和一个时间事件处理器`proc`作为参数，将一个新的时间事件添加到服务器，这个新的时间事件将在当前时间的milliseconds毫秒之后到达，而事件的处理器为proc。

例如，如果服务器当前所保存的时间事件如图12-9所示。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6947e4c0e3194f27b449f7598b8975a4~tplv-k3u1fbpfcp-zoom-1.image)

那么当程序以50毫秒和handler_3处理器为参数，在时间1385877599980 ( 2013年12月1日零时前20毫秒)时调用`aeCreateTimeEvent`函数，服务器将创建ID为3的时间事件，这时服务器所保存的时间事件将如图12-8所示。

`ae.c/aeDeleteFileEvent`函数接受一个时间事件ID作为参数，然后从服务器中删除该ID所对应的时间事件。

举个例子，如果服务器当前保存的时间事件如图12-8所示，那么当程序调用`aeDeleteFileEvent(3)`之后，服务器保存的时间事件将变成图12-9所示的样子。

`ae.c/aeSearchNearestTimer`函数返回到达时间距离当前时间最接近的那个时间事件。

举个例子，如果当前时间为1385877599980 ( 2013年12月1日零时前20毫秒)，而服务器当前保存的时间事件如图12-8所示，那么调用`aeSearchNearestTimer`函数将返回ID为2的事件。

`ae.c/processTimeEvents`函数是时间事件的执行器，这个函数会遍历所有已到达的时间事件,并调用这些事件的处理器。已到达指的是：时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳。

举个例子，如果服务器保存的时间事件如图12-8所示，并且当前时间为1385877600010(2013年12月1日零时之后10毫秒)，那么processTimeEvents函数将处理图中ID为2和1的时间事件，因为这两个事件的到达时间都大于等于1385877600010。

## serverCron

持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/servercron函数负责执行，它的主要工作包括:

-   更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。
-   清理数据库中的过期键值对。

<!---->

-   关闭和清理连接失效的客户端。
-   尝试进行AOF或RDB持久化操作。

<!---->

-   如果服务器是主服务器，那么对从服务器进行定期同步。
-   如果处于集群模式，对集群进行定期同步和连接测试。

Redis服务器以周期性事件的方式来运行servercron函数，在服务器运行期间，每隔一段时间，servercron就会执行一次，直到服务器关闭为止。

在 Redis2.6版本，服务器默认规定serverCron每秒运行10次，平均每间隔100毫秒运行一次。

从 Redis2.8开始，用户可以通过修改hz选项来调整serverCron的每秒执行次数，具体信息请参考示例配置文件redis.conf关于hz选项的说明。

# 事件的调度和执行

因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。

事件的调度和执行由ae.c/aeProcessEvents函数负责，以下是该函数的伪代码表示:

```
def aeProcessEvents ():

    #获取到达时间离当前时间最接近的时间事件
    time_event = aesearchNearestTimer()
        
    #计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now ()
        
    #如果事件已到达，那么remaind_ms 的值可能为负数，将它设定为0
    if remaind_ms < 0;
        remaind_ms = 0
            
    #根据remaind_ms的值,创建timeval结构
    timeval = create_timeval_with_ms(remaind_ms)
            
    #阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定
    #如果remaind_ms 的值为0，那么aeApiPoll调用之后马上返回，不阻塞
    aeApiPoll (timeval)
            
    #处理所有已产生的文件事件
    /**
    processFileEvents
    **/
            
    #处理所有已到达的时间事件
    processTi.rmeEvents()
            
```

将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20350620f1464c11bd4db34c9332ff41~tplv-k3u1fbpfcp-zoom-1.image)

以下是事件的调度和执行规则:

1.  aeApiPoll函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这个方法既可以避免服务器对时间事件进行频繁的轮询（忙等待)，也可以确保aeApiPoll函数不会阻塞过长时间。
1.  因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，时间会逐渐向时间事件所设置的到达时间逼近，并最终来到到达时间，这时服务器就可以开始处理到达的时间事件了。

<!---->

3.  **对文件事件和时间事件的处理都是同步、有序、原子地执行的**，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可地减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。比如说，在命令回复处理器将一个命令回复写人到客户端套接字时，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用break跳出写人循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。
3.  因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间，通常会比时间事件设定的到达时间稍晚一些。

# 总结

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96f4a4572247418b85d8c09f3ffc566e~tplv-k3u1fbpfcp-zoom-1.image)

