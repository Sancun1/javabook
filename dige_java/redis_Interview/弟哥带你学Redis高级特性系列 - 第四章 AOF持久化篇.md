## 公众号：“弟哥带你进大厂”，让你知识成体系的公众号，一定要关注，我们一起进大厂

# AOF持久化的实现

AOF持久化功能的实现可以分为命令追加(append)、文件写人、文件同步( sync)三个步骤。

## 命令追加

当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof buf缓冲区的末尾:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/445cb1996d9a4fbb9b2f79ee3e9a6ccc~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5dcc2fdc1c048838a9a1dc65c0367d3~tplv-k3u1fbpfcp-zoom-1.image)

### AOF文件的写入和同步

Redis 的服务器进程就是一个事件循环(loop )，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。

因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246432cdb3cf49ad849131c74dfffcd3~tplv-k3u1fbpfcp-zoom-1.image)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/182b210222f34551ba5ea59dc3442c20~tplv-k3u1fbpfcp-zoom-1.image)

# AOF文件的载入与数据还原

因为AOF 文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。

Redis读取AOF文件并还原数据库状态的详细步骤如下:

1.  创建一个不带网络连接的伪客户端( fake client )：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。
1.  从AOF文件中分析并读取出一条写命令。

<!---->

3.  使用伪客户端执行被读出的写命令。
3.  一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。

当完成以上步骤之后，AOF文件所保存的数据库状态就会被完整地还原出来，整个过程如图11-2所示。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46a2ba0635c24f55849a3f7bc1ad2989~tplv-k3u1fbpfcp-zoom-1.image)

# 重写

## 重写的实现

虽然Redis将生成新AOF 文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF 文件重写并不需要对现有的AOF 文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。

所有类型的键都可以用同样的方法去减少AOF 文件中的命令数量。首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。

注：

在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了`redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD`常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。

在目前版本中，`REDIS_AOF_REWRITE_ITEMS_PER_CMD`常量的值为64，这也就是说，如果一个集合键包含了超过64个元素，那么重写程序会用多条SADD命令来记录这个集合，并且每条命令设置的元素数量也为64个:

## 后台重写

Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行，这样做可以同时达到两个目的:

-   子进程进行AOF重写期间，服务器进程(父进程）可以继续处理命令请求。
-   子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。

不过，使用子进程也有一个问题需要解决,因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。比如下图

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4adb625f7414679846728e9c918c101~tplv-k3u1fbpfcp-zoom-1.image)

为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区，如图11-4所示。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f47cd76c890e42f3af60a4b57a256f14~tplv-k3u1fbpfcp-zoom-1.image)

这也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作:

1.  执行客户端发来的命令。
1.  将执行后的写命令追加到AOF缓冲区。

<!---->

3.  将执行后的写命令追加到AOF重写缓冲区。

这样一来可以保证:

-   AOF缓冲区的内容会定期被写入和同步到AOF 文件，对现有AOF 文件的处理工作会如常进行。
-   从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。

当子进程完成AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作:

1.  **将AOF重写缓冲区中的所有内容写人到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。**
1.  **对新的AOF 文件进行改名，原子地( atomic）覆盖现有的AOF 文件，完成新旧两个AOF文件的替换。**

这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。

# 总结：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a0712b529644ef187e661e4838eeca9~tplv-k3u1fbpfcp-zoom-1.image)

